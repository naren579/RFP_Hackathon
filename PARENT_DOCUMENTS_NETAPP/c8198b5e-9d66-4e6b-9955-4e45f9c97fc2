Swift object management

After Swift objects have been ingested in the StorageGRID system, they are managed by the information lifecycle management (ILM) rules in the active ILM policies. ILM rules and ILM policies determine how

994

StorageGRID creates and distributes copies of object data and how it manages those copies over time. For example, an ILM rule might apply to objects in specific Swift containers and might specify that multiple object copies be saved to several data centers for a certain number of years. Contact your NetApp Professional Services consultant or StorageGRID administrator if you need to understand how the grid’s ILM rules and policies will affect the objects in your Swift tenant account.

Conflicting client requests

Conflicting client requests, such as two clients writing to the same key, are resolved on a "latest-wins" basis. The timing for the "latest-wins" evaluation is based on when the StorageGRID system completes a given request, and not on when Swift clients begin an operation. Consistency guarantees and controls

By default, StorageGRID provides read-after-write consistency for newly created objects and eventual consistency for object updates and HEAD operations. Any GET following a successfully completed PUT will be able to read the newly written data. Overwrites of existing objects, metadata updates, and deletes are eventually consistent. Overwrites generally take seconds or minutes to propagate, but can take up to 15 days.

StorageGRID also allows you to control consistency on a per container basis. Consistency values provide a balance between the availability of the objects and the consistency of those objects across different Storage Nodes and sites, as required by your application. Recommendations for implementing Swift REST API

You should follow these recommendations when implementing the Swift REST API for use with StorageGRID.

Recommendations for HEADs to non-existent objects

If your application routinely checks to see if an object exists at a path where you don’t expect the object to actually exist, you should use the "Available" consistency. For example, you should use the "Available" consistency if your application performs a HEAD operation to a location before performing a PUT operation to that location.

Otherwise, if the HEAD operation does not find the object, you might receive a high number of 500 Internal Server errors if one or more Storage Nodes are unavailable.

You can set the "Available" consistency for each container using the PUT container consistency request. You view set the "Available" consistency for each container using the GET container consistency request. Recommendations for object names

For containers that are created in StorageGRID 11.4 or later, restricting object names to meet performance best practices is no longer required. For example, you can now use random values for the first four characters of object names.

For containers that were created in releases earlier than StorageGRID 11.4, continue to follow these recommendations for object names:

You should not use random values as the first four characters of object names. This is in contrast to the former AWS recommendation for name prefixes. Instead, you should use non-random, non-unique prefixes, such as image.

995

• If you do follow the former AWS recommendation to use random and unique characters in name prefixes,

you should prefix the object names with a directory name. That is, use this format: mycontainer/mydir/f8e3-image3132.jpg

Instead of this format:

mycontainer/f8e3-image3132.jpg

Recommendations for "range reads"

If the global option to compress stored objects is enabled, Swift client applications should avoid performing GET object operations that specify a range of bytes be returned. These "range read" operations are inefficient because StorageGRID must effectively uncompress the objects to access the requested bytes. GET Object operations that request a small range of bytes from a very large object are especially inefficient; for example, it is very inefficient to read a 10 MB range from a 50 GB compressed object.

If ranges are read from compressed objects, client requests can time out.

If you need to compress objects and your client application must use range reads, increase the read timeout for the application. Test Swift REST API configuration

You can use the Swift CLI to test your connection to the StorageGRID system and to verify that you can read and write objects.

Before you begin 995

• If you do follow the former AWS recommendation to use random and unique characters in name prefixes,

you should prefix the object names with a directory name. That is, use this format: mycontainer/mydir/f8e3-image3132.jpg

Instead of this format:

mycontainer/f8e3-image3132.jpg

Recommendations for "range reads"